{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Propeller","text":"<p>Propeller is a cutting-edge orchestrator for WebAssembly (Wasm) workloads across the Cloud-Edge continuum. It enables seamless deployment of Wasm applications from powerful cloud servers to constrained microcontrollers, combining flexibility, security, and performance.</p>"},{"location":"#features","title":"\ud83c\udf1f Features","text":"<ul> <li>\ud83c\udf10 Cloud-Edge Orchestration: Deploy Wasm workloads effortlessly across diverse environments, from robust cloud servers to lightweight microcontrollers.</li> <li>\u26a1 Fast Boot Times: Take advantage of Wasm's near-instant startup for efficient workload execution.</li> <li>\ud83d\udce6 FaaS Deployment: Enable Function-as-a-Service (FaaS) capabilities for scalable and event-driven applications.</li> <li>\ud83d\udda5\ufe0f OCI Registry Support: Push and pull Wasm workloads from OCI-compliant registries for streamlined workflow integration.</li> <li>\ud83d\udd27 WAMR on Zephyr RTOS: Deploy lightweight Wasm workloads on constrained devices running Zephyr RTOS via the WebAssembly Micro Runtime (WAMR).</li> <li>\ud83d\udee0\ufe0f Powerful Service Mesh: Integrates with SuperMQ for secure, efficient IoT device communication.</li> <li>\ud83d\udd12 Security at the Core: Propeller ensures secure workload execution and communication for IoT environments.</li> </ul>"},{"location":"#how-it-works","title":"\ud83d\udee0\ufe0f How It Works","text":"<ol> <li>Develop in WebAssembly: Write portable, lightweight Wasm workloads for your application.</li> <li>Register Workloads: Push your workloads to an OCI-compliant registry for easy deployment.</li> <li>Deploy Anywhere: Use Propeller to orchestrate and manage workload deployment across the cloud, edge, and IoT devices.</li> <li>Monitor &amp; Scale: Leverage real-time monitoring and dynamic scaling to optimize your system's performance.</li> </ol>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"developer-guide/","title":"Developer's Guide","text":""},{"location":"developer-guide/#getting-propeller","title":"Getting Propeller","text":"<p>Propeller source can be found in the official Propeller GitHub repository. You should fork this repository in order to make changes to the project. The forked version of the repository should be cloned using the following:</p> <pre><code>git clone https://github.com/your-github-username/propeller.git $SOMEPATH/propeller\ncd $SOMEPATH/propeller\n</code></pre>"},{"location":"developer-guide/#building-propeller","title":"Building Propeller","text":""},{"location":"developer-guide/#prerequisites","title":"Prerequisites","text":"<p>To build Propeller, you will need the following:</p> <ul> <li>A Go compiler (Go 1.23 or later)</li> <li>Make</li> <li>Docker</li> <li>Wasmtime</li> <li>TinyGo</li> </ul>"},{"location":"developer-guide/#building","title":"Building","text":"<p>Use the GNU Make tool to build all Propeller services:</p> <pre><code>make all\n</code></pre> <p>This will build Propeller for your platforms.</p> <p>To build Propeller for other platforms, use the following:</p> OS Architecture Command Linux amd64 <code>GOOS=linux GOARCH=amd64 make all</code> Linux arm64 <code>GOOS=linux GOARCH=arm64 make all</code> Windows amd64 <code>GOOS=windows GOARCH=amd64 make all</code> Darwin amd64 <code>GOOS=darwin GOARCH=amd64 make all</code>"},{"location":"developer-guide/#building-an-individual-service","title":"Building an individual service","text":"<p>You can build individual services using the following:</p> <pre><code>make &lt;service&gt;\n</code></pre> <p>For example, to build the <code>manager</code> service, use the following:</p> <pre><code>make manager\n</code></pre> <p>The built binaries will be located in the <code>build</code> directory.</p>"},{"location":"developer-guide/#building-examples","title":"Building examples","text":"<p>You can build examples using the following:</p> <pre><code>make &lt;example&gt;\n</code></pre> <p>For example, to build the <code>addition</code> example, use the following:</p> <pre><code>make addition\n</code></pre> <p>This compiles the addition example to wasm and can be located in the <code>build</code> directory.</p> <p>To test the addition example, use the following:</p> <pre><code>wasmtime --invoke add ./build/addition.wasm 1 2\n</code></pre> <p>This will output something like:</p> <pre><code>warning: using `--invoke` with a function that takes arguments is experimental and may break in the future\nwarning: using `--invoke` with a function that returns values is experimental and may break in the future\n3\n</code></pre>"},{"location":"developer-guide/#installing","title":"Installing","text":"<p>Once you have built Propeller, you can install it using the following:</p> <pre><code>make install\n</code></pre> <p>This will install Propeller to the <code>GOBIN</code> directory.</p>"},{"location":"developer-guide/#linter","title":"Linter","text":"<p>Propeller uses golangci-lint to lint the code. You can run the linter using the following:</p> <pre><code>make lint\n</code></pre>"},{"location":"developer-guide/#magistrala","title":"Magistrala","text":""},{"location":"developer-guide/#starting-magistrala","title":"Starting Magistrala","text":"<p>To start Magistrala, use the following:</p> <pre><code>make start-magistrala\n</code></pre> <p>This will in the background run <code>docker compose -f docker/compose.yaml up -d</code> which will start the Magistrala services.</p> <p>You can override the configuration or add some extra parameters to the docker compose configuration.</p>"},{"location":"developer-guide/#stopping-magistrala","title":"Stopping Magistrala","text":"<p>Magistrala can be stopped using the following:</p> <pre><code>make stop-magistrala\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Before proceeding, install the following prerequisites:</p> <ul> <li>A Go compiler (Go 1.23 or later)</li> <li>Make</li> <li>Docker</li> <li>Wasmtime</li> <li>TinyGo</li> <li>Magistrala CLI</li> <li>Mosquitto</li> </ul>"},{"location":"getting-started/#start-docker-composition","title":"Start Docker composition","text":"<p>Start docker composition</p> <pre><code>cd propeller\nmake start-magistrala\n</code></pre> <p>To install the Magistrala CLI, follow the instructions here.</p>"},{"location":"getting-started/#provision-magistrala","title":"Provision Magistrala","text":"<p>Login as admin user</p> <pre><code>USER_TOKEN=$(magistrala-cli users token admin 12345678 | jq -r .access_token)\n</code></pre> <p>Create a domain</p> <pre><code>DOMAIN_ID=$(magistrala-cli domains create demo demo $USER_TOKEN | jq -r .id)\n</code></pre> <p>Create a thing called manager</p> <pre><code>magistrala-cli things create '{\"name\": \"Propeller Manager\", \"tags\": [\"manager\", \"propeller\"], \"status\": \"enabled\"}' $DOMAIN_ID $USER_TOKEN\n</code></pre> <p>This will output a response like the following</p> <pre><code>{\n  \"created_at\": \"2024-12-20T09:56:05.241227Z\",\n  \"credentials\": {\n    \"secret\": \"64b3742e-beee-4bd9-8673-a7b1dbfe4115\"\n  },\n  \"domain_id\": \"c1908400-701b-4f55-82ae-45a5997b2df6\",\n  \"id\": \"70fc2b08-a2ce-4294-8003-aeb3df0ff505\",\n  \"name\": \"Propeller Manager\",\n  \"status\": \"enabled\",\n  \"tags\": [\"manager\", \"propeller\"],\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre> <p>Set the following environment variables from the respose</p> <pre><code>export MANAGER_THING_ID=\"&lt;id&gt;\"\nexport MANAGER_THING_KEY=\"&lt;secret&gt;\"\n</code></pre> <p>For example</p> <pre><code>export MANAGER_THING_ID=\"70fc2b08-a2ce-4294-8003-aeb3df0ff505\"\nexport MANAGER_THING_KEY=\"64b3742e-beee-4bd9-8673-a7b1dbfe4115\"\n</code></pre> <p>Create a channel called manager</p> <pre><code>magistrala-cli channels create '{\"name\": \"Propeller Manager\", \"tags\": [\"manager\", \"propeller\"], \"status\": \"enabled\"}' $DOMAIN_ID $USER_TOKEN\n</code></pre> <pre><code>{\n  \"created_at\": \"2024-12-20T09:57:12.510144Z\",\n  \"domain_id\": \"c1908400-701b-4f55-82ae-45a5997b2df6\",\n  \"id\": \"f8201a3c-7fd3-4468-bc85-8824ec0ab4d3\",\n  \"name\": \"Propeller Manager\",\n  \"status\": \"enabled\",\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre> <p>Set the following environment variables from the respose</p> <pre><code>export MANAGER_CHANNEL_ID=\"&lt;id&gt;\"\n</code></pre> <p>For example</p> <pre><code>export MANAGER_CHANNEL_ID=\"f8201a3c-7fd3-4468-bc85-8824ec0ab4d3\"\n</code></pre> <p>Connect the thing to the manager channel</p> <pre><code>magistrala-cli things connect $MANAGER_THING_ID $MANAGER_CHANNEL_ID $DOMAIN_ID $USER_TOKEN\n</code></pre> <p>Create a thing called proplet</p> <pre><code>magistrala-cli things create '{\"name\": \"Propeller Proplet\", \"tags\": [\"proplet\", \"propeller\"], \"status\": \"enabled\"}' $DOMAIN_ID $USER_TOKEN\n</code></pre> <pre><code>{\n  \"created_at\": \"2024-12-20T09:58:00.282984Z\",\n  \"credentials\": {\n    \"secret\": \"ab8543bd-1f4b-4df1-b252-4d35c7aaffa2\"\n  },\n  \"domain_id\": \"c1908400-701b-4f55-82ae-45a5997b2df6\",\n  \"id\": \"65f31506-80f1-48f4-b2d2-ff2487d4baad\",\n  \"name\": \"Propeller Proplet\",\n  \"status\": \"enabled\",\n  \"tags\": [\"proplet\", \"propeller\"],\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre> <p>Set the following environment variables from the respose</p> <pre><code>export PROPLET_THING_ID=\"&lt;id&gt;\"\nexport PROPLET_THING_KEY=\"&lt;secret&gt;\"\n</code></pre> <p>For example</p> <pre><code>export PROPLET_THING_ID=\"65f31506-80f1-48f4-b2d2-ff2487d4baad\"\nexport PROPLET_THING_KEY=\"ab8543bd-1f4b-4df1-b252-4d35c7aaffa2\"\n</code></pre> <p>Connect the thing to the manager channel</p> <pre><code>magistrala-cli things connect $PROPLET_THING_ID $MANAGER_CHANNEL_ID $DOMAIN_ID $USER_TOKEN\n</code></pre>"},{"location":"getting-started/#start-the-manager","title":"Start the manager","text":"<p>To start the manager, run the following command</p> <pre><code>export MANAGER_THING_ID=\"\"\nexport MANAGER_THING_KEY=\"\"\nexport PRMANAGER_CHANNEL_ID=\"\"\nexport PROPLET_THING_ID=\"\"\nexport PROPLET_THING_KEY=\"\"\npropeller-manager\n</code></pre>"},{"location":"getting-started/#start-the-proplet","title":"Start the proplet","text":"<p>To start the proplet, run the following command</p> <pre><code>export MANAGER_THING_ID=\"\"\nexport MANAGER_THING_KEY=\"\"\nexport PROPLET_CHANNEL_ID=\"\"\nexport PROPLET_THING_ID=\"\"\nexport PROPLET_THING_KEY=\"\"\npropeller-proplet\n</code></pre>"},{"location":"getting-started/#postman-colletion","title":"Postman Colletion","text":"<p>This is a collection of the API calls that can be used to interact with the Propeller system.</p>"},{"location":"getting-started/#api","title":"API","text":""},{"location":"getting-started/#list-proplets","title":"List Proplets","text":"<pre><code>curl -X GET \"http://localhost:7070/proplets\"\n</code></pre> <p>This will output a response like the following</p> <pre><code>{\n  \"offset\": 0,\n  \"limit\": 100,\n  \"total\": 1,\n  \"proplets\": [\n    {\n      \"id\": \"65f31506-80f1-48f4-b2d2-ff2487d4baad\",\n      \"name\": \"Edouard-Harker\",\n      \"task_count\": 0,\n      \"alive\": true,\n      \"alive_history\": [\n        \"2024-12-20T13:06:40.004843025+03:00\",\n        \"2024-12-20T13:06:50.004307995+03:00\",\n        \"2024-12-20T13:07:00.005793874+03:00\",\n        \"2024-12-20T13:07:10.005762532+03:00\",\n        \"2024-12-20T13:07:20.006582332+03:00\",\n        \"2024-12-20T13:07:30.005886582+03:00\",\n        \"2024-12-20T13:07:40.005318901+03:00\",\n        \"2024-12-20T13:07:50.003822571+03:00\",\n        \"2024-12-20T13:08:00.006378219+03:00\",\n        \"2024-12-20T13:08:10.005855688+03:00\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"getting-started/#create-task","title":"Create task","text":"<pre><code>curl -X POST \"http://localhost:7070/tasks\" \\\n-H \"Content-Type: application/json\" \\\n-d '{\"name\": \"add\", \"inputs\": [10, 20]}'\n</code></pre> <p>This will output a response like the following</p> <pre><code>{\n  \"id\": \"ee8012e7-f3b1-47f1-a109-b21eb3b0e21d\",\n  \"name\": \"add\",\n  \"state\": 0,\n  \"inputs\": [10, 20],\n  \"start_time\": \"0001-01-01T00:00:00Z\",\n  \"finish_time\": \"0001-01-01T00:00:00Z\",\n  \"created_at\": \"2024-12-20T13:09:28.925730577+03:00\",\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre>"},{"location":"getting-started/#get-a-task","title":"Get a task","text":"<pre><code>curl -X GET \"http://localhost:7070/tasks/e5bcc74e-9af3-4f09-b663-44dc260ab809\"\n</code></pre> <p>This will output a response like the following</p> <pre><code>{\n  \"id\": \"1a211574-987c-4213-9266-af1640e1af95\",\n  \"name\": \"add\",\n  \"state\": 0,\n  \"inputs\": [10, 20],\n  \"start_time\": \"0001-01-01T00:00:00Z\",\n  \"finish_time\": \"0001-01-01T00:00:00Z\",\n  \"created_at\": \"2024-12-20T13:10:37.848159052+03:00\",\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre>"},{"location":"getting-started/#upload-wasm-file","title":"Upload Wasm File","text":"<pre><code>curl -X PUT \"http://localhost:7070/tasks/e5bcc74e-9af3-4f09-b663-44dc260ab809/upload\" \\\n-F 'file=@&lt;propeller_path&gt;/build/addition.wasm'\n</code></pre>"},{"location":"getting-started/#start-a-task","title":"Start a task","text":"<pre><code>curl -X POST \"http://localhost:7070/tasks/e5bcc74e-9af3-4f09-b663-44dc260ab809/start\"\n</code></pre>"},{"location":"getting-started/#stop-a-task","title":"Stop a task","text":"<pre><code>curl -X POST \"http://localhost:7070/tasks/e5bcc74e-9af3-4f09-b663-44dc260ab809/stop\"\n</code></pre>"},{"location":"manager/","title":"Manager","text":""},{"location":"proplet/","title":"Proplet","text":""},{"location":"proplet/#proplet-command-handling","title":"Proplet Command Handling","text":""},{"location":"proplet/#start-command-flow","title":"Start Command Flow","text":"<p>The start command is sent by the Manager to the Proplet on the topic <code>channels/$CHANNEL_ID/messages/control/manager/start</code></p>"},{"location":"proplet/#1-parse-the-start-command","title":"1. Parse the Start Command","text":"<p>The MQTT message payload is unmarshaled into a <code>StartRequest</code> structure containing the <code>AppName</code> and any required parameters for the application. If the payload is invalid or <code>AppName</code> is missing, an error is logged, and no further action is taken.</p>"},{"location":"proplet/#2-publish-a-fetch-request","title":"2. Publish a Fetch Request","text":"<p>A fetch request is sent to the Registry Proxy to retrieve the WebAssembly (Wasm) binary chunks for the specified application. This request is published to the topic <code>channels/$CHANNEL_ID/messages/registry/proplet</code>.</p>"},{"location":"proplet/#3-wait-for-wasm-binary-chunks","title":"3. Wait for Wasm Binary Chunks","text":"<p>The system monitors the reception of Wasm chunks from the Registry Proxy, which are published to the topic <code>channels/$CHANNEL_ID/messages/registry/server</code> and processed by the <code>handleChunk</code> function.</p>"},{"location":"proplet/#4-assemble-and-validate-chunks","title":"4. Assemble and Validate Chunks","text":"<p>Once all chunks are received, as determined by comparing the number of received chunks to the <code>TotalChunks</code> field in the chunk metadata, the chunks are assembled into a complete Wasm binary and validated to ensure integrity.</p>"},{"location":"proplet/#5-deploy-and-run-the-application","title":"5. Deploy and Run the Application","text":"<p>The assembled Wasm binary is passed to the Wazero runtime for instantiation and execution, where the specified function (e.g., <code>main</code>) in the Wasm module is invoked.</p>"},{"location":"proplet/#runtime-functions-startapp","title":"Runtime Functions: StartApp","text":"<p>The <code>StartApp</code> function in <code>runtime.go</code> handles the instantiation and execution of Wasm modules. It:</p> <ol> <li>Validate Input Parameters: Ensures <code>appName</code>, <code>wasmBinary</code>, and <code>functionName</code> are provided and valid. Errors are returned if any parameter is missing or invalid.</li> <li>Acquire Mutex Lock: Locks the runtime to ensure thread-safe access to the <code>modules</code> map.</li> <li>Check for Existing App Instance: Verifies if the app is already running. If found, an error is returned to prevent duplicate instances.</li> <li>Instantiate the Wasm Module: Passes the <code>wasmBinary</code> to the Wazero runtime's <code>Instantiate</code> method to create a Wasm module.</li> <li>Retrieve the Exported Function: Locates the <code>functionName</code> in the module. If the function is missing, the module is closed, and an error is returned.</li> <li>Store the Module in the Runtime: Saves the instantiated module in the <code>modules</code> map for tracking running applications.</li> <li>Release Mutex Lock: Unlocks the runtime after the module is added to the map.</li> <li>Return the Exported Function: Returns the Wasm function for execution.</li> </ol>"},{"location":"proplet/#6-log-success-or-errors","title":"6. Log Success or Errors","text":"<p>A success message is logged if the application starts successfully, while detailed errors are logged if any step in the process (e.g., chunk assembly, instantiation, or execution) fails.</p>"},{"location":"proplet/#stop-command-flow","title":"Stop Command Flow","text":"<p>The stop command is sent by the Manager to the Proplet on the topic <code>channels/$CHANNEL_ID/messages/control/manager/stop</code></p>"},{"location":"proplet/#1-parse-the-stop-command","title":"1. Parse the Stop Command","text":"<p>The MQTT message payload is unmarshaled into a <code>StopRequest</code> structure containing the <code>AppName</code> of the application to stop. If the payload is invalid or <code>AppName</code> is missing, an error is logged, and no further action is taken.</p>"},{"location":"proplet/#2-stop-the-application","title":"2. Stop the Application","text":"<p>The <code>StopApp</code> method in the Wazero runtime is invoked, which checks if the application is running, closes the corresponding Wasm module, and removes the application from the runtime's internal tracking.</p>"},{"location":"proplet/#runtime-functions-stopapp","title":"Runtime Functions: StopApp","text":"<p>The <code>StopApp</code> function in <code>runtime.go</code> stops and cleans up a running Wasm module. It:</p> <ol> <li>Validate Input Parameters: Checks if <code>appName</code> is provided. If missing, an error is returned.</li> <li>Acquire Mutex Lock: Locks the runtime to ensure thread-safe access to the <code>modules</code> map.</li> <li>Check for Running App: Looks up the app in the <code>modules</code> map. If the app is not found, an error is returned.</li> <li>Close the Wasm Module: Calls the module's <code>Close</code> method to release all resources associated with the app. If closing fails, an error is logged and returned.</li> <li>Remove the App from Runtime: Deletes the app entry from the <code>modules</code> map to update the runtime's state.</li> <li>Release Mutex Lock: Unlocks the runtime after the app has been removed from the map.</li> </ol>"},{"location":"proplet/#3-log-success-or-errors","title":"3. Log Success or Errors","text":"<p>A success message is logged with the text <code>\"App '&lt;AppName&gt;' stopped successfully.\"</code> if the application stops successfully. If the application is not running or an error occurs during the stop operation, detailed error information is logged.</p> <p>The Manager knows which Proplet is on which channel through the following mechanisms:</p> <ol> <li>Startup Notification (<code>create</code> topic):</li> </ol> <p>When a Proplet starts, it publishes a message on the topic:</p> <p><code>bash    channels/$MANAGER_CHANNEL_ID/messages/control/proplet/create</code></p> <p>The payload of this message includes the <code>PropletID</code> and <code>ChannelID</code>, notifying the Manager about the mapping of Proplet IDs to their respective channels:</p> <p><code>json    {      \"PropletID\": \"{PropletID}\",      \"ChanID\": \"{ChannelID}\"    }</code></p> <ol> <li>Liveliness Updates (<code>alive</code> topic):</li> </ol> <p>To ensure that the Proplet is still active, it periodically publishes messages on the topic:</p> <p><code>bash    channels/$MANAGER_CHANNEL_ID/messages/control/proplet/alive</code></p> <p>The payload contains the same <code>PropletID</code> and <code>ChannelID</code> information. This helps the Manager maintain an updated map of active Proplets and their channels:</p> <p><code>json    {      \"status\": \"alive\",      \"PropletID\": \"{PropletID}\",      \"ChanID\": \"{ChannelID}\"    }</code></p> <ol> <li>Last Will &amp; Testament (LWT):</li> </ol> <p>If the Proplet goes offline unexpectedly, the MQTT broker automatically publishes a message on the same <code>alive</code> topic with a payload indicating the Proplet's offline status:</p> <p><code>json    {      \"status\": \"offline\",      \"PropletID\": \"{PropletID}\",      \"ChanID\": \"{ChannelID}\"    }</code></p> <p>These mechanisms ensure that the Manager is always aware of the active Proplets and their corresponding channels. The Manager can utilize this data to send specific control commands or monitor the Proplets effectively.</p>"},{"location":"proplet/#registry-workflow","title":"Registry Workflow","text":"<ol> <li> <p>Proplet Fetches Wasm Binary:</p> </li> <li> <p>Publishes a fetch request on the <code>proplet</code> topic.</p> </li> <li> <p>Waits for chunks on the <code>server</code> topic.</p> </li> <li> <p>Proplet Handles Registry Updates:</p> </li> <li>Subscribes to the <code>updateRegistry</code> topic.</li> <li>Updates the registry configuration upon receiving a valid payload.</li> <li>Publishes the status (success or failure) to the <code>registry</code> topic.</li> </ol>"},{"location":"proplet/#1-fetch-request","title":"1. Fetch Request","text":"<p>The Proplet uses this topic to request Wasm binary chunks for a specific application from the Registry Proxy.</p> <ul> <li>Topic:</li> </ul> <p><code>bash   channels/$CHANNEL_ID/messages/registry/proplet</code></p> <ul> <li>Payload is a JSON object containing the name of the application (<code>app_name</code>) for which the WebAssembly (Wasm) binary chunks are requested:</li> </ul> <p><code>json   {     \"app_name\": \"{AppName}\"   }</code></p>"},{"location":"proplet/#2-image-chunks-delivery","title":"2. Image Chunks Delivery","text":"<p>The Registry Proxy publishes Wasm binary chunks to this topic for the Proplet to assemble into a complete binary. The Proplet monitors this topic to receive the chunks sequentially.</p> <ul> <li>Topic:</li> </ul> <p><code>bash   channels/$CHANNEL_ID/messages/registry/server</code></p> <ul> <li>Payload is a JSON object representing a single chunk of the requested Wasm binary:</li> </ul> <p><code>json   {     \"app_name\": \"{AppName}\",     \"chunk_idx\": {ChunkIndex},     \"total_chunks\": {TotalChunks},     \"data\": \"{Base64EncodedChunkData}\"   }</code></p>"},{"location":"proplet/#3-registry-configuration-update","title":"3. Registry Configuration Update","text":"<ul> <li>Allows the Manager to update the Proplet's registry configuration dynamically.</li> </ul> <p><code>bash   channels/$CHANNEL_ID/messages/control/manager/updateRegistry</code></p> <ul> <li>Payload is a JSON object containing the new registry URL and token for updating the Proplet's registry configuration:</li> </ul> <p><code>json   {     \"registry_url\": \"{NewRegistryURL}\",     \"registry_token\": \"{NewRegistryToken}\"   }</code></p>"},{"location":"proplet/#4-acknowledgment-for-registry-updates","title":"4. Acknowledgment for Registry Updates","text":"<ul> <li>The Proplet uses this topic to acknowledge whether the registry configuration update was successful or failed.</li> </ul> <p><code>bash   channels/$CHANNEL_ID/messages/control/manager/registry</code></p> <ul> <li> <p>Payload is a JSON object indicating the success or failure of a registry update:</p> </li> <li> <p>Success:</p> <p><code>json {   \"status\": \"success\" }</code></p> </li> <li> <p>Failure:</p> <p><code>json {   \"status\": \"failure\",   \"error\": \"{ErrorMessage}\" }</code></p> </li> </ul>"}]}